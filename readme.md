# My First Blockchain in Go

Here i'll build my fisrt blockchain in go.

## How to run this code?

### Wallet

Open the terminal, go to the root path and run the follow command to start wallet interface:

```Shell
go run ./cmd/web/wallet_server/
```

### Blockchain

Open a new terminal, go to the root path and run the follow command to start blockchain:

```Shell
go run ./cmd/api/blockchain_server
```

### Developer Tests

Open a new terminal, go to the root path and run the follow command to run statics testes (bets method to test some isolated function):

```Shell
go run ./cmd/cli
```

## Paths

| Dir     | Subject       |
| :----------- | :---------- |
| /      | root dir   |
| /cmd/api     |go file to run blockchain api|
| /cmd/cli     |go file to run some tests|
| /cmd/web     |go tile to run web template of wallet|
| /config      |Some CONST to the project   |
| /img      |Images to this documentation   |
| /models/block      |models for the blockchain   |
| /models/wallet      |models for the wallet   |
| /server      |Server and Handlers  |
| /templates      |Wallet template   |
| /utils      |Utils for Json, Encrypt and Nodes of blockchain    |

## About this blockchain architecture

![Architecture](/goblockchain/img/Macro.png)

### About Code

All documentation generated by AI (Amazon Q Explanation)

#### Block - /models/block/block.go

The provided code defines a `Block` struct and related methods in the Go programming language. This code is likely part of
an implementation for a blockchain system.

##### Block struct

The `Block` struct represents a single block in the blockchain. It contains the following fields:

1. `timestamp`: An integer representing the Unix timestamp (nanoseconds since January 1, 1970) when the block was created.
2. `nonce`: An integer value used in the proof-of-work algorithm to mine the block.
3. `previousHash`: A 32-byte array representing the hash of the previous block in the chain.
4. `transactions`: A slice of pointers to `Transaction` structs, which likely represent the transactions included in this block.

##### NewBlock

The `NewBlock` function is a constructor that creates a new `Block` instance with the provided `nonce`, `previousHash`, and `transactions`.

##### PreviousHash, Transactions, Nonce

The `PreviousHash`, `Transactions`, and `Nonce` methods are simple getter methods that return the corresponding fields of the `Block` struct.

##### Print

The `Print` method prints the block's timestamp, nonce, previous hash, and all the transactions included in the block.

##### Hash

The `Hash` method calculates and returns the SHA-256 hash of the block's data. It first marshals the block struct into a JSON byte slice and then calculates the SHA-256 hash of that byte slice.

##### MarshalJSON

The `MarshalJSON` and `UnmarshalJSON` methods are used for JSON serialization and deserialization of the `Block` struct. These methods are necessary because the `previousHash` field is a fixed-size array, which cannot be directly marshaled and unmarshaled by the standard JSON package.

In summary, this code defines the structure of a block in a blockchain system, along with methods for creating, printing, hashing, and serializing/deserializing blocks. It is a crucial component in building a blockchain application in Go.

#### Blockchain - /models/block/blockchain.go

The provided code defines the `Blockchain` struct and its related methods in the Go programming language. This struct represents the entire blockchain and provides functionality to manage and interact with the blockchain.

##### Blockchain Struct

- `transactionPool`: A slice of pointers to `Transaction` structs, representing the pool of pending transactions.
- `chain`: A slice of pointers to `Block` structs, representing the actual blockchain.
- `blockchainAddress`: A string representing the address of the current blockchain node.
- `port`: An unsigned 16-bit integer representing the port number on which the blockchain node is running.
- `mux`: A mutex (mutual exclusion) used for synchronizing access to shared data structures.
- `neighbors`: A slice of strings representing the addresses of neighboring blockchain nodes.
- `muxNeighbors`: A mutex used for synchronizing access to the `neighbors` slice.

##### NewBlockchain

- This function is a constructor that creates a new `Blockchain` instance.
- It initializes the blockchain with a genesis block (the first block in the chain) by calling `CreateBlock` with a nonce of 0 and an empty previous hash.
- It sets the `blockchainAddress` and `port` fields with the provided values.

##### Chain

- This method returns a copy of the `chain` slice, which represents the entire blockchain.

##### Run

- This method starts two background tasks: `StartSyncNeighbors` and `ResolveConflicts`.
- `StartSyncNeighbors` periodically updates the list of neighboring nodes.
- `ResolveConflicts` checks for longer valid chains from neighboring nodes and updates the local chain if a longer valid chain is found.

##### SetNeighbors

- This method populates the `neighbors` slice with the addresses of neighboring nodes within a specified IP range and port range.

##### SyncNeighbors

- This method acquires the `muxNeighbors` mutex lock and calls `SetNeighbors` to update the list of neighboring nodes.

##### StartSyncNeighbors

- This method calls `SyncNeighbors` and then schedules itself to be called again after a specified time interval (`BLOCKCHAIN_NEIGHBOR_SYNC_TIME_SEC`).

##### TransactionPool

- This method returns a copy of the `transactionPool` slice, which represents the pool of pending transactions.

##### ClearTransactionPool

- This method clears the `transactionPool` slice, effectively removing all pending transactions.

##### MarshalJSON and UnmarshalJSON

- These methods are used for JSON serialization and deserialization of the `Blockchain` struct.
- They handle the conversion between the `Blockchain` struct and its JSON representation.

##### CreateBlock

- This method creates a new `Block` instance with the provided `nonce` and `previousHash`.
- It appends the new block to the `chain` slice and clears the `transactionPool`.
- It also sends a request to neighboring nodes to clear their transaction pools.

##### LastBlock

- This method returns a pointer to the last block in the `chain` slice.

##### Print (Blockchain)

- This method prints the entire blockchain by iterating over the `chain` slice and calling the `Print` method of each block.

##### CreateTransaction

- This method creates a new transaction and adds it to the local `transactionPool`.
- It also broadcasts the transaction to neighboring nodes by sending a PUT request to their `/transactions` endpoint.

##### AddTransaction

- This method adds a new transaction to the `transactionPool` after verifying the transaction signature.
- It performs additional checks, such as ensuring sufficient balance (commented out in the provided code).

##### VerifyTransactionSignature

- This method verifies the signature of a transaction using the provided public key and signature.
- It calculates the hash of the transaction data and verifies the signature using the `ecdsa.Verify` function.

##### CopyTransactionPool

- This method creates a copy of the `transactionPool` slice by creating new `Transaction` instances with the same data.

##### ValidProof

- This method checks if a given `nonce` and `previousHash` combination, along with the provided `transactions`, produce a valid proof-of-work solution based on the specified `difficulty`.

##### ProofOfWork

- This method performs the proof-of-work computation by iteratively incrementing the `nonce` value until a valid proof is found.
- It uses the `ValidProof` method to check the validity of each nonce value.

##### Mining

- This method performs the mining process for the blockchain.
- It acquires the `mux` mutex lock to ensure thread safety.
- It adds a mining reward transaction to the `transactionPool`.
- It calls `ProofOfWork` to find a valid nonce value.
- It creates a new block with the found nonce and the hash of the previous block.
- It broadcasts a request to neighboring nodes to trigger consensus resolution.

##### StartMining

- This method calls `Mining` and then schedules itself to be called again after a specified time interval (`MINING_TIMER_SEC`).

##### CalculateTotalAmount

- This method calculates the total amount of cryptocurrency associated with a given blockchain address by iterating over all blocks and transactions in the chain.

##### ValidChain

- This method checks if a given chain of blocks is valid by verifying the integrity of each block's hash and proof-of-work solution.

##### ResolveConflicts

- This method checks for longer valid chains from neighboring nodes and updates the local chain if a longer valid chain is found.
- It iterates over the neighboring nodes, retrieves their chains, and checks if any of them are longer and valid.
- If a longer valid chain is found, it replaces the local chain with the longer one.

In summary, this code defines the core functionality of a blockchain system, including creating and managing the blockchain, adding transactions, mining new blocks, and synchronizing with neighboring nodes to maintain consensus and resolve conflicts.

#### Transaction - /models/block/transaction.go

The provided code defines a `Transaction` struct and related methods in the Go programming language. This code is likely part of an implementation for a blockchain system.

##### Transaction Struct

- `txid`: A string representing the unique identifier of the transaction.
- `senderBlockchainAddress`: A string representing the blockchain address of the sender.
- `recipientBlockchainAddress`: A string representing the blockchain address of the recipient.
- `value`: A float32 representing the amount of cryptocurrency being transferred.

##### NewTransaction

- This function is a constructor that creates a new `Transaction` instance with the provided `txID`, `sender`, `recipient`, and `value`.

##### createTxID

- This function generates a unique transaction ID (txid) by concatenating the `sender`, `recipient`, and `value` fields, and then computing the SHA-256 hash of the resulting string.
- The hash is then encoded as a hexadecimal string, which becomes the `txid`.

##### Print (Transaction)

- This method prints the details of the transaction, including the sender's blockchain address, the recipient's blockchain address, and the value being transferred.

##### MarshalJSON (Trancation)

- This method is used for JSON serialization of the `Transaction` struct.
- It creates a new struct with the same fields as `Transaction` and marshals it to a JSON byte slice.

##### UnmarshalJSON

- This method is used for JSON deserialization of the `Transaction` struct.
- It unmarshals the provided JSON byte slice into a temporary struct with pointers to the `Transaction` fields.
- It then updates the `Transaction` fields with the unmarshaled values.

The `Transaction` struct represents a single transaction in the blockchain system, containing information about the sender, recipient, and the amount of cryptocurrency being transferred.

The `NewTransaction` function is a constructor that creates a new `Transaction` instance with the provided parameters.

The `createTxID` function generates a unique transaction ID by hashing the transaction details (sender, recipient, and value) using the SHA-256 algorithm. This ensures that each transaction has a unique identifier, which is essential for maintaining the integrity of the blockchain.

The `Print` method provides a way to print the details of a transaction in a human-readable format.

The `MarshalJSON` and `UnmarshalJSON` methods are used for JSON serialization and deserialization, respectively. These methods are necessary for storing and transmitting transactions in a standardized format, which is crucial for interoperability and data exchange within the blockchain system.

Overall, this code defines the structure and behavior of transactions in a blockchain system, enabling the creation, identification, and representation of cryptocurrency transfers between blockchain addresses.

#### Transaction Request - /models/block/transaction_request.go

The provided code defines a `TransactionRequest` struct and a `Validate` method in the Go programming language. This code is likely part of an implementation for a blockchain system and is used to represent and validate incoming transaction requests.

##### TransactionRequest Struct

- `TxID`: A pointer to a string representing the unique identifier of the transaction.
- `SenderBlockchainAddress`: A pointer to a string representing the blockchain address of the sender.
- `RecipientBlockchainAddress`: A pointer to a string representing the blockchain address of the recipient.
- `SenderPublicKey`: A pointer to a string representing the public key of the sender.
- `Value`: A pointer to a float32 representing the amount of cryptocurrency being transferred.
- `Signature`: A pointer to a string representing the digital signature of the transaction.

##### Validate

- This method checks if all the required fields of the `TransactionRequest` struct are non-nil (i.e., have been assigned values).
- It returns `true` if all the required fields are present, and `false` otherwise.

The `TransactionRequest` struct represents an incoming request to create a new transaction in the blockchain system. It contains the necessary information for creating a transaction, such as the sender's and recipient's blockchain addresses, the amount to be transferred, the sender's public key, and a digital signature.

The `Validate` method is used to perform basic validation of the `TransactionRequest` struct before processing the transaction further. It checks if all the required fields have been provided by the client or external system that sent the transaction request. If any of the required fields are missing (i.e., have a `nil` value), the method returns `false`, indicating that the transaction request is invalid and should not be processed further.

This validation step is crucial in a blockchain system to ensure the integrity and correctness of the transactions being added to the blockchain. By validating the incoming transaction requests, the system can prevent malformed or incomplete transactions from being processed, which could potentially lead to errors or security vulnerabilities.

It's important to note that the `Validate` method only performs a basic validation check on the presence of required fields. In a real-world implementation, additional validation checks may be necessary, such as verifying the validity of the blockchain addresses, checking the format of the public key and signature, and ensuring that the sender has sufficient funds to perform the transaction.

Overall, this code provides a simple structure for representing incoming transaction requests and a basic validation mechanism to ensure that the required fields are present before further processing.

#### Amount Response - /models/block/amount_response.go

The provided code defines an `AmountResponse` struct and its `MarshalJSON` method in the Go programming language. This code is likely part of an implementation for a blockchain system and is used to represent and marshal the amount of cryptocurrency in a transaction or other related operations.

##### AmountResponse Struct

- `Amount`: A float32 field representing the amount of cryptocurrency.

##### MarshalJSON (Amount Response)

- This method is used for JSON serialization of the `AmountResponse` struct.
- It creates a new anonymous struct with a single field `Amount` of type float32, which is assigned the value of `ar.Amount` (where `ar` is the receiver instance of `AmountResponse`).
- It then marshals this anonymous struct to a JSON byte slice using the `json.Marshal` function from the `encoding/json` package.
- The resulting JSON byte slice is returned as the output of the `MarshalJSON` method.

The `AmountResponse` struct is a simple data structure that holds a single value representing the amount of cryptocurrency. This struct could be used in various contexts within a blockchain system, such as returning the balance of a blockchain address, the amount of a transaction, or the mining reward for a new block.

The `MarshalJSON` method is a custom implementation of the JSON marshaling process for the `AmountResponse` struct. By default, the `encoding/json` package in Go would marshal the `AmountResponse` struct by creating a JSON object with a field named after the struct field name (in this case, `"Amount"`). However, the `MarshalJSON` method allows you to customize the JSON representation of the struct.

In this case, the `MarshalJSON` method creates an anonymous struct with a single field named `"amount"` (note the lowercase `"a"`), which is assigned the value of `ar.Amount`. This anonymous struct is then marshaled to a JSON byte slice using the `json.Marshal` function. The resulting JSON representation will be a JSON object with a single field named `"amount"` and its value set to the value of `ar.Amount`.

For example, if `ar.Amount` is 10.5, the JSON output of `MarshalJSON` would be `{"amount":10.5}`.

This custom JSON marshaling implementation can be useful in scenarios where you need to conform to a specific JSON format or structure expected by other systems or clients interacting with the blockchain system.

Overall, this code provides a simple data structure for representing an amount of cryptocurrency and a custom JSON marshaling implementation to control the JSON representation of this data structure.

#### Wallet - /models/wallet/wallet.go

##### Wallet Struct and Methods

The provided code defines a `Wallet` struct and its associated methods in the Go programming language. The purpose of this code is to generate a new cryptocurrency wallet with a private key, public key, and blockchain address.

##### Wallet Struct

The `Wallet` struct has three fields:

- `privateKey` (an ECDSA private key)
- `publicKey` (the corresponding ECDSA public key)
- `blockchainAddress` (a string representing the wallet's address on the blockchain)

##### NewWallet Function

The `NewWallet` function creates a new instance of the `Wallet` struct. It performs the following steps:

1. Generates a new ECDSA private key using the `ecdsa.GenerateKey` function with the elliptic curve `P256` and a cryptographically secure random number generator (`rand.Reader`).
2. Derives the public key from the private key using the `&w.privateKey.PublicKey` expression.
3. Generates the blockchain address by performing a series of hashing operations on the public key:
   - The public key's X and Y coordinates are hashed using SHA-256.
   - The SHA-256 hash is then hashed using RIPEMD-160.
   - A version byte (0x00 for the main network) is prepended to the RIPEMD-160 hash.
   - The extended RIPEMD-160 hash is double-hashed using SHA-256.
   - The first 4 bytes of the second SHA-256 hash are used as a checksum.
   - The checksum is appended to the extended RIPEMD-160 hash.
   - The resulting byte string is encoded using Base58 encoding to produce the final blockchain address.

##### Wallet Methods

The `Wallet` struct provides the following methods:

- `PrivateKey() *ecdsa.PrivateKey`: Returns the private key.
- `PrivateKeyStr() string`: Returns the private key as a string.
- `PublicKey() *ecdsa.PublicKey`: Returns the public key.
- `PublicKeyStr() string`: Returns the public key as a string.
- `BlockchainAddress() string`: Returns the blockchain address.
- `MarshalJSON() ([]byte, error)`: Implements the `json.Marshaler` interface to allow the `Wallet` struct to be serialized to JSON format, including the private key, public key, and blockchain address.

##### Summary

In summary, this code generates a new cryptocurrency wallet with a private key, public key, and blockchain address using the ECDSA algorithm and various hashing operations. The blockchain address is derived from the public key through a series of hashing steps and Base58 encoding.

#### Transaction - /models/wallet/transaction.go

The provided code snippet is written in Go programming language and defines a `Transaction` struct and related functions for creating and managing transactions in a blockchain system.

##### Transaction Struct (Wallet)

- The `Transaction` struct represents a single transaction in the blockchain.
- It contains fields such as `txid` (transaction ID), `senderPrivateKey`, `senderPublicKey`, `senderBlockchainAddress`, `recipientBlockchainAddress`, and `value` (the amount being transferred).

##### NewTransaction Function

- This function creates a new `Transaction` instance.
- It takes the sender's private key, public key, sender's address, recipient's address, and the value (amount) as arguments.
- It generates a unique transaction ID (`txID`) using the `createTxID` function and returns a pointer to the new `Transaction` instance.

##### GetTxID Function

- This function returns a pointer to the transaction ID (`txid`) field of the `Transaction` struct.

##### createTxID Function

- This function generates a unique transaction ID based on the sender's address, recipient's address, and the value (amount) being transferred.
- It concatenates these values into a single string, computes the SHA-256 hash of the string, and encodes the hash as a hexadecimal string, which becomes the transaction ID.

##### GenerateSignature Function

- This function generates a digital signature for the transaction using the sender's private key.
- It first marshals (converts) the `Transaction` struct into a JSON byte slice.
- Then, it computes the SHA-256 hash of the JSON byte slice.
- Finally, it uses the `ecdsa.Sign` function to generate the signature (r, s) using the sender's private key and the computed hash.
- The signature is returned as a `utils.Signature` struct.

##### MarshalJSON Function

- This function is used to customize the JSON representation of the `Transaction` struct.
- It creates an anonymous struct with the desired JSON field names and values, and marshals (converts) it into a JSON byte slice.
- This byte slice is then returned as the JSON representation of the `Transaction` struct.

#### Transaction Request - /models/wallet/transaction_request.go

This code defines a struct called `TransactionRequest` and a method called `Validate` associated with it.

##### Transaction Request Struct

- The `TransactionRequest` struct represents the data required to initiate a transaction in a blockchain system.
- It contains the following fields:
  - `TxID`: A pointer to a string that represents the transaction ID.
  - `SenderPrivateKey`: A pointer to a string that holds the private key of the sender.
  - `SenderBlockchainAddress`: A pointer to a string that holds the blockchain address of the sender.
  - `RecipientBlockchainAddress`: A pointer to a string that holds the blockchain address of the recipient.
  - `SenderPublicKey`: A pointer to a string that holds the public key of the sender.
  - `Value`: A pointer to a string that represents the value or amount being transferred.
- The `json` tags are used to specify the JSON field names when marshaling or unmarshaling the struct.

##### Validate Method

- The `Validate` method is a receiver function associated with the `TransactionRequest` struct.
- It checks if all the required fields of the `TransactionRequest` struct are non-nil (i.e., have been assigned values).
- If any of the following fields are `nil`, the method returns `false`:
  - `SenderPrivateKey`
  - `SenderBlockchainAddress`
  - `RecipientBlockchainAddress`
  - `SenderPublicKey`
  - `Value`
- If all the required fields are non-nil, the method returns `true`.

The purpose of this code is to define a data structure (`TransactionRequest`) that holds the necessary information for initiating a transaction in a blockchain system, and to provide a validation method (`Validate`) to ensure that all the required fields are properly set before proceeding with the transaction.

#### Blockchain Server  - /server/blockchain_server.go

This code defines a server for a blockchain application written in Go. Here's a breakdown of what the code does:

##### Imports

The code imports necessary packages, including those for:

- Encoding/decoding JSON
- Working with the blockchain and wallet models
- Utilities
- Handling HTTP requests

##### Cache

A map called `cache` is created to store blockchain instances, with the key being the string "blockchain".

##### BlockchainServer Struct

The `BlockchainServer` struct represents the blockchain server and has a single field `port` of type `uint16` to store the server's port number.

##### NewBlockchainServer

This function creates a new instance of the `BlockchainServer` struct with the provided port number.

##### GetBlockchain

This method retrieves the blockchain instance from the `cache`. If the blockchain doesn't exist in the cache, it creates a new wallet for the miner, initializes a new blockchain with the miner's address and the server's port, and stores it in the cache.

##### GetChain

This method handles HTTP GET requests to retrieve the entire blockchain as JSON.

##### Transactions

This method handles HTTP requests related to transactions:

- GET: Retrieves the list of transactions in the transaction pool as JSON.
- POST: Creates a new transaction by decoding the request body and adding it to the blockchain.
- PUT: Updates an existing transaction in the transaction pool.
- DELETE: Clears the transaction pool.

##### Mine

This method handles HTTP GET requests to mine a new block and add it to the blockchain.

##### StartMine

This method handles HTTP GET requests to start the mining process.

##### Amount

This method handles HTTP GET requests to calculate the total amount of a specific blockchain address.

##### Consensus

This method handles HTTP PUT requests to resolve conflicts between different blockchain instances by replacing the current blockchain with the longest valid chain.

##### Run (blockchain server)

This method starts the blockchain server by registering HTTP handlers for the various endpoints and listening for incoming requests on the specified port.

#### Wallet Server  - /server/wallet_server.go

This code is a part of a Go server implementation for handling wallet-related operations in a blockchain application.

##### Imports (wallet server)

The code imports necessary packages for:

- Encoding/decoding JSON
- Working with blockchain and wallet models
- Utilities
- HTML templates
- Handling HTTP requests

##### Constants

The `tempDir` constant is defined to store the path to the directory containing HTML templates.

##### WalletServer Struct

The `WalletServer` struct represents the wallet server and has two fields:

- `port` (uint16) for the server's port number
- `gateway` (string) for the blockchain server's gateway URL

##### NewWalletServer

This function creates a new instance of the `WalletServer` struct with the provided port number and gateway URL.

##### Port and Gateway

These methods return the `port` and `gateway` values of the `WalletServer` instance, respectively.

##### Index

This method handles HTTP GET requests for the root path ("/"). It parses and executes the "index.html" template from the `tempDir` directory.

##### Wallet (wallet server)

This method handles HTTP POST requests for the "/wallet" path. It creates a new wallet, marshals it to JSON, and writes the JSON data to the response.

##### CreateTransaction (wallet server)

This method handles HTTP POST requests for the "/transaction" path. It decodes the request body into a `TransactionRequest` struct, validates the request data, creates a new transaction with the provided details, and sends the transaction to the blockchain server's "/transactions" endpoint. The response status is written back to the client.

##### WalletAmount

This method handles HTTP GET requests for the "/wallet/amount" path. It retrieves the blockchain address from the query parameters, sends a GET request to the blockchain server's "/amount" endpoint with the blockchain address, and writes the response (either the amount or a failure status) to the client.

##### Run (wallet server)

This method starts the wallet server by registering HTTP handlers for the various endpoints and listening for incoming requests on the specified port.

#### ECDSA /utils/ecdsa.go

The provided code snippet is written in Go programming language and is part of a package called `utils`. This package contains functions related to Elliptic Curve Digital Signature Algorithm (ECDSA), which is a cryptographic algorithm used for digital signatures.

##### Breakdown of the Code

1. **`Signature` struct**
   - This struct represents a digital signature, which consists of two big integers, `R` and `S`.

2. **`String()` method**
   - This method is defined on the `Signature` struct and returns a string representation of the signature by concatenating the hexadecimal values of `R` and `S`.

3. **`String2BigIntTuple` function**
   - This function takes a string as input and converts it into a tuple of two big integers.
   - It does this by decoding the first 64 characters of the string as the first big integer (`bix`) and the remaining characters as the second big integer (`biy`).

4. **`SignatureFromString` function**
   - This function takes a string as input and returns a pointer to a `Signature` struct.
   - It uses the `String2BigIntTuple` function to convert the input string into two big integers, which are then used to create a new `Signature` struct.

5. **`PublicKeyFromString` function**
   - This function takes a string as input and returns a pointer to an `ecdsa.PublicKey` struct.
   - It uses the `String2BigIntTuple` function to convert the input string into two big integers, which are then used to create a new `ecdsa.PublicKey` struct with the elliptic curve `P256`.

6. **`PrivateKeyFromString` function**
   - This function takes a string and a pointer to an `ecdsa.PublicKey` as input and returns a pointer to an `ecdsa.PrivateKey` struct.
   - It decodes the input string into a big integer, which is then used to create a new `ecdsa.PrivateKey` struct with the provided `ecdsa.PublicKey`.

##### Summary (ECDSA)

In summary, this code provides utility functions for working with ECDSA signatures, public keys, and private keys. It allows converting between string representations and their corresponding data structures, which can be useful in various cryptographic operations, such as digital signature verification and key management.

#### Neighbor /utils/neighbor.go

The provided code is a Go package named `utils` that contains functions related to network operations and IP address manipulation. Here's a breakdown of the code:

1. **`IsFouncHost` function**
   - This function takes a host string (IP address or hostname) and a port number (uint16) as input.
   - It attempts to establish a TCP connection to the specified host and port using `net.DialTimeout`.
   - If the connection is successful within the 1-second timeout, it returns `true`, indicating that the host is reachable on the given port.
   - If the connection fails, it returns `false`.

2. **`PATTERN` variable**
   - This is a regular expression pattern that matches IPv4 addresses.
   - It is compiled using `regexp.MustCompile` and stored as a global variable for reuse.

3. **`FindNeighbors` function**
   - This function takes the following parameters:
     - `myHost`: The IP address or hostname of the current host.
     - `myPort`: The port number of the current host.
     - `startIp` and `endIp`: The range of IP addresses to scan for neighbors (the last octet of the IP address).
     - `startPort` and `endPort`: The range of port numbers to scan for neighbors.
   - It first checks if `myHost` is a valid IPv4 address using the `PATTERN` regular expression.
   - If `myHost` is valid, it extracts the prefix (the first three octets) of the IP address.
   - It then iterates over the specified range of IP addresses and port numbers, constructing potential neighbor addresses by combining the prefix with the last octet and the port number.
   - For each potential neighbor address, it checks if the address is different from the current host's address and if the host is reachable using the `IsFouncHost` function.
   - If a reachable neighbor is found, it is added to the `neighbors` slice.
   - Finally, the function returns the `neighbors` slice containing the reachable neighbor addresses.

4. **`GetHost` function**
   - This function attempts to retrieve the current host's IP address.
   - It first tries to get the hostname using `os.Hostname`.
   - If the hostname is successfully retrieved, it uses `net.LookupHost` to resolve the hostname to a list of IP addresses.
   - If the hostname resolution is successful, it returns the third IP address from the list (assuming it's a valid IPv4 address).
   - If any errors occur during the process, it returns the loopback IP address `127.0.0.1`.

The code seems to be part of a larger application that deals with network discovery and communication. The `FindNeighbors` function can be used to scan a range of IP addresses and port numbers to find reachable hosts, which could be useful in peer-to-peer networking or distributed systems. The `GetHost` function provides a way to retrieve the current host's IP address, which might be necessary for various networking operations.
